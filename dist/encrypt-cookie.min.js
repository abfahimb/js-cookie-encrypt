"use strict";
/*! encrypt-cookiejs v1.0.2 | MIT (c) 2024 Abdullah Al Fahim | https://github.com/abfahimb/encrypt-cookieJS */Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncryptCookie=void 0;
// Enhanced CookieCrypto class
class CookieCrypto{constructor(t){this.privateKey=t.privateKey,this.saltLength=t.saltLength||16}generateRandomSalt(){const t=new Uint8Array(this.saltLength);return window.crypto.getRandomValues(t),Array.from(t,(t=>String.fromCharCode(t))).join("")}expandKey(t,e){const n=[];for(let o=0;o<Math.max(null==t?void 0:t.length,null==e?void 0:e.length);o++){const s=t.charCodeAt(o%(null==t?void 0:t.length)),i=e.charCodeAt(o%(null==e?void 0:e.length));n.push(String.fromCharCode(s^i))}return n.join("")}xorEncryptDecrypt(t,e){const n=this.generateRandomSalt(),o=this.expandKey(e,n);let s="";for(let e=0;e<(null==t?void 0:t.length);e++)s+=String.fromCharCode(t.charCodeAt(e)^o.charCodeAt(e%(null==o?void 0:o.length)));return this.encodeToBase64(n+s)}encodeToBase64(t){return btoa(unescape(encodeURIComponent(t)))}decodeFromBase64(t){return decodeURIComponent(escape(atob(t)))}encrypt(t){return this.xorEncryptDecrypt(t,this.privateKey)}decrypt(t){const e=this.decodeFromBase64(t),n=e.substring(0,this.saltLength),o=e.substring(this.saltLength),s=this.expandKey(this.privateKey,n);let i="";for(let t=0;t<(null==o?void 0:o.length);t++)i+=String.fromCharCode(o.charCodeAt(t)^s.charCodeAt(t%(null==s?void 0:s.length)));return i}}
// Main EncryptCookie class with enhanced features
class EncryptCookie{constructor(t){var e;this.storageKey=t.storageKey,this.crypto=new CookieCrypto(t.cryptoConfig),this.defaultOptions=t.defaultOptions||{},this.encryptByDefault=null===(e=t.cryptoConfig.encryptByDefault)||void 0===e||e}set(t,e={},{encrypt:n,merge:o}={}){if("undefined"==typeof document)return;let s=t;if(o){const e=this.get()||{};s=Object.assign(Object.assign({},e),t)}const i=null!=n?n:this.encryptByDefault,r=Object.assign(Object.assign({},this.defaultOptions),e),a=i?this.crypto.encrypt(JSON.stringify(s)):JSON.stringify(s);let c=`${this.storageKey}=${a}`;
// Append cookie options in the same way as in the provided snippet
if(r.path&&(c+=`; path=${r.path}`),r.expires){c+=`; expires=${("number"==typeof r.expires?new Date(Date.now()+r.expires):r.expires).toUTCString()}`}r.domain&&(c+=`; domain=${r.domain}`),r.secure&&(c+="; secure"),r.sameSite&&(c+=`; samesite=${r.sameSite}`),r.httpOnly&&(c+="; httponly"),
// Set the cookie
document.cookie=c}
// Get value by nested path
getByPath(t){const e=this.get();return e?t.toString().split(".").reduce(((t,e)=>t&&t[e]),e):null}
// Set value by nested path
setByPath(t,e,n={}){const o=this.get()||{},s=t.toString().split(".");let i=o;for(let t=0;t<(null==s?void 0:s.length)-1;t++){const e=s[t];e in i||(i[e]={}),i=i[e]}i[s[(null==s?void 0:s.length)-1]]=e,this.set(o,n)}updateByPath(t,e,n={}){const o=this.get()||{},s=t.toString().split(".");let i=o;for(let t=0;t<(null==s?void 0:s.length)-1;t++){const e=s[t];e in i||(i[e]={}),i=i[e]}const r=s[(null==s?void 0:s.length)-1];r in i&&"object"==typeof i[r]&&"object"==typeof e?
// Merge the objects if the key exists and both are objects
i[r]=Object.assign(Object.assign({},i[r]),e):
// Otherwise, just set the value
i[r]=e,this.set(o,n)}deleteByPath(t){if("undefined"==typeof document)return;const e=this.get()||{},n=t.toString().split(".");let o=e;
// Traverse the path to get to the parent object
for(let t=0;t<n.length-1;t++){const e=n[t];if(!(e in o))return;// Path does not exist, nothing to delete
o=o[e]}const s=n[n.length-1];s in o&&(delete o[s],// Delete the field at the path
this.set(e))}
// Check if cookie exists
has(t){const e=this.get();return!!e&&(!t||
// Type guard to ensure `data` is an object
"object"==typeof e&&null!==e&&t in e)}
// Extend cookie expiration
extend(t,e={}){const n=this.get();n&&this.set(n,Object.assign(Object.assign({},e),{expires:new Date(Date.now()+1e3*t)}))}
// Get all cookies with same domain
static getAllCookies(t){const e={};return"undefined"==typeof document||document.cookie.split(";").forEach((n=>{const[o,s]=n.split("=").map((t=>t.trim()));t&&!n.includes(`domain=${t}`)||(e[o]=s)})),e}
// Clear all cookies with same domain
static clearAll(t,e="/"){const n=EncryptCookie.getAllCookies(t);Object.keys(n).forEach((n=>{let o=`${n}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=${e}`;t&&(o+=`; domain=${t}`),document.cookie=o}))}
// Original methods with some enhancements
get(t){try{if("undefined"==typeof document)return null;const e=document.cookie.match(new RegExp("(^| )"+this.storageKey+"=([^;]+)")),n=e?e[2]:null;if(!n)return null;let o;return o=this.encryptByDefault?JSON.parse(this.crypto.decrypt(n)):JSON.parse(n),t&&o&&t in o?o[t]||null:o}catch(t){return console.error("Failed to retrieve or parse cookie data:",t),this.clear(),null}}update(t,e={}){if("undefined"==typeof document)return;const n=this.get()||{},o=Object.assign(Object.assign({},n),t);this.set(o,e)}deleteFields(t){if("undefined"==typeof document)return;const e=this.get()||{};t.forEach((t=>delete e[t])),this.set(e)}clear(t={}){const e=Object.assign(Object.assign({},this.defaultOptions),t);let n=`${encodeURIComponent(this.storageKey)}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=${e.path||"/"}`;this.appendCookieOptions(n,e),document.cookie=n}
// Utility methods
appendCookieOptions(t,e){if(e.expires){t+=`; expires=${("number"==typeof e.expires?new Date(Date.now()+1e3*e.expires):e.expires).toUTCString()}`}return e.path&&(t+=`; path=${e.path}`),e.domain&&(t+=`; domain=${e.domain}`),e.secure&&(t+="; secure"),e.sameSite&&(t+=`; samesite=${e.sameSite}`),e.httpOnly&&(t+="; httponly"),t}}exports.EncryptCookie=EncryptCookie,exports.default=EncryptCookie;
//# sourceMappingURL=encrypt-cookie.js.map